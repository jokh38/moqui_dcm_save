#!/bin/bash
# Pre-push hook for C++ projects - Testing and Dynamic Analysis
# This hook runs comprehensive tests, static analysis, and performance checks

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}üîç Pre-push Hook: Testing and Dynamic Analysis${NC}"
echo "=================================================="

# Detect build system
BUILD_SYSTEM="cmake"
if [ -f "meson.build" ]; then
    BUILD_SYSTEM="meson"
elif [ -f "CMakeLists.txt" ]; then
    BUILD_SYSTEM="cmake"
else
    echo -e "${YELLOW}‚ö†Ô∏è  Could not detect build system, defaulting to CMake${NC}"
    BUILD_SYSTEM="cmake"
fi

echo -e "${GREEN}‚úì Detected build system: $BUILD_SYSTEM${NC}"

# Function to run command and check result
run_check() {
    local description="$1"
    local command="$2"
    local critical="${3:-true}"

    echo -e "\n${BLUE}üìã $description${NC}"
    echo "Running: $command"

    if eval "$command"; then
        echo -e "${GREEN}‚úÖ $description - PASSED${NC}"
        return 0
    else
        if [ "$critical" = "true" ]; then
            echo -e "${RED}‚ùå $description - FAILED${NC}"
            echo -e "${RED}Please fix the issues above before pushing.${NC}"
            return 1
        else
            echo -e "${YELLOW}‚ö†Ô∏è  $description - WARNING${NC}"
            return 0
        fi
    fi
}

# Check if build directory exists and is configured
if [ ! -d "build" ]; then
    echo -e "${YELLOW}üìÅ Build directory not found, creating...${NC}"
    mkdir -p build
fi

# 1. Configure build system
echo -e "\n${BLUE}üîß Configuring build system...${NC}"
if [ "$BUILD_SYSTEM" = "cmake" ]; then
    if [ ! -f "build/CMakeCache.txt" ]; then
        echo "Configuring CMake..."
        if command -v ninja &> /dev/null; then
            cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug
        else
            cmake -B build -DCMAKE_BUILD_TYPE=Debug
        fi
    fi
else
    if [ ! -f "build/build.ninja" ]; then
        echo "Configuring Meson..."
        meson setup build --buildtype=debug
    fi
fi

# 2. Build the project
echo -e "\n${BLUE}üèóÔ∏è  Building project...${NC}"
if [ "$BUILD_SYSTEM" = "cmake" ]; then
    if run_check "Build Project" "cmake --build build --parallel $(nproc)" true; then
        BUILD_PASSED=true
    else
        BUILD_PASSED=false
    fi
else
    if run_check "Build Project" "meson compile -C build" true; then
        BUILD_PASSED=true
    else
        BUILD_PASSED=false
    fi
fi

# 3. Run test suite
echo -e "\n${BLUE}üß™ Running test suite...${NC}"
if [ "$BUILD_PASSED" = "true" ]; then
    if [ "$BUILD_SYSTEM" = "cmake" ]; then
        if run_check "Test Suite" "ctest --test-dir build --output-on-failure" true; then
            TESTS_PASSED=true
        else
            TESTS_PASSED=false
        fi
    else
        if run_check "Test Suite" "meson test -C build --verbose" true; then
            TESTS_PASSED=true
        else
            TESTS_PASSED=false
        fi
    fi
else
    echo -e "${RED}‚ùå Skipping tests due to build failure${NC}"
    TESTS_PASSED=false
fi

# 4. Comprehensive static analysis with clang-tidy
echo -e "\n${BLUE}üîç Running comprehensive static analysis...${NC}"
if command -v clang-tidy &> /dev/null; then
    # Create compile commands if not available
    if [ ! -f "build/compile_commands.json" ]; then
        echo "Generating compile commands..."
        if [ "$BUILD_SYSTEM" = "cmake" ]; then
            cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        fi
    fi

    # Run comprehensive clang-tidy analysis
    if [ -f "build/compile_commands.json" ]; then
        run_check "Static Analysis (clang-tidy)" "clang-tidy src/**/*.cpp -p build --warnings-as-errors='*' --quiet" false
    else
        echo -e "${YELLOW}‚ö†Ô∏è  compile_commands.json not found, skipping static analysis${NC}"
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  clang-tidy not found, skipping static analysis${NC}"
fi

# 5. Run cppcheck for additional static analysis
echo -e "\n${BLUE}üîç Additional static analysis (cppcheck)...${NC}"
if command -v cppcheck &> /dev/null; then
    run_check "Static Analysis (cppcheck)" "cppcheck src/ --enable=all --inconclusive --std=c++17 --suppress=missingIncludeSystem --xml --xml-version=2 2>cppcheck-report.xml" false
else
    echo -e "${YELLOW}‚ö†Ô∏è  cppcheck not found, skipping additional static analysis${NC}"
fi

# 6. Run sanitizers if available (Debug build)
echo -e "\n${BLUE}üõ°Ô∏è  Running sanitizers...${NC}"
if [ "$BUILD_PASSED" = "true" ]; then
    # Check if sanitizers are available in the build
    if [ "$BUILD_SYSTEM" = "cmake" ]; then
        # Try to build and run with sanitizers
        echo "Testing with AddressSanitizer..."
        if cmake --build build --config Debug -t test 2>/dev/null; then
            # Look for ASan-enabled binary
            ASAN_BINARY=$(find build -name "*test*" -type f -executable 2>/dev/null | head -1)
            if [ -n "$ASAN_BINARY" ]; then
                echo "Running AddressSanitizer on $ASAN_BINARY"
                run_check "AddressSanitizer" "$ASAN_BINARY" false
            fi
        fi
    fi
fi

# 7. Code coverage analysis (if gcov/lcov available)
echo -e "\n${BLUE}üìä Code coverage analysis...${NC}"
if command -v gcov &> /dev/null && command -v lcov &> /dev/null; then
    if [ "$BUILD_PASSED" = "true" ] && [ "$TESTS_PASSED" = "true" ]; then
        echo "Generating coverage report..."
        if [ "$BUILD_SYSTEM" = "cmake" ]; then
            # Rebuild with coverage flags
            cmake -B build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS="--coverage -g -O0" -DCMAKE_C_FLAGS="--coverage -g -O0"
            cmake --build build

            # Run tests again to generate coverage data
            ctest --test-dir build

            # Generate coverage report
            run_check "Coverage Analysis" "lcov --capture --directory build --output-file coverage.info && lcov --remove coverage.info '/usr/*' --output-file coverage.info && lcov --list coverage.info" false
        fi
    fi
else
    echo -e "${YELLOW}üì¶ gcov/lcov not found, skipping coverage analysis${NC}"
fi

# 8. Performance benchmarks (if available)
echo -e "\n${BLUE}‚ö° Performance benchmarks...${NC}"
if [ -f "tests/benchmarks/" ] || [ -f "benchmark.cpp" ]; then
    if [ "$BUILD_PASSED" = "true" ]; then
        # Look for benchmark executables
        BENCHMARK_BINARY=$(find build -name "*benchmark*" -type f -executable 2>/dev/null | head -1)
        if [ -n "$BENCHMARK_BINARY" ]; then
            run_check "Performance Benchmarks" "$BENCHMARK_BINARY" false
        fi
    fi
else
    echo -e "${YELLOW}üìù No benchmarks found, skipping performance tests${NC}"
fi

# 9. Memory leak detection with Valgrind (if available)
echo -e "\n${BLUE}üß† Memory leak detection...${NC}"
if command -v valgrind &> /dev/null && [ "$TESTS_PASSED" = "true" ]; then
    # Find test binary
    TEST_BINARY=$(find build -name "*test*" -type f -executable 2>/dev/null | head -1)
    if [ -n "$TEST_BINARY" ]; then
        echo "Running Valgrind memory check..."
        run_check "Memory Leak Detection" "valgrind --leak-check=full --error-exitcode=1 $TEST_BINARY" false
    fi
else
    echo -e "${YELLOW}üì¶ valgrind not found or no tests, skipping memory leak detection${NC}"
fi

# 10. Check for undefined behavior with UBSan (if supported)
echo -e "\n${BLUE}üîç Undefined behavior detection...${NC}"
if command -v clang++ &> /dev/null; then
    echo "Testing with UBSan..."
    # This is a simple check - in a real project you'd have a separate UBSan build
    echo "UBSan integration would require dedicated build configuration"
    echo "Consider adding UBSan flags: -fsanitize=undefined -fno-sanitize-recover=all"
else
    echo -e "${YELLOW}üì¶ clang++ not found, skipping UBSan checks${NC}"
fi

# Final status check
echo -e "\n${BLUE}==================================================${NC}"
echo -e "${BLUE}üèÅ Pre-push Hook Summary${NC}"
echo "=================================================="

# Check critical failures
CRITICAL_FAILURES=false

if [ "$BUILD_PASSED" != "true" ]; then
    echo -e "${RED}‚ùå Build failed${NC}"
    CRITICAL_FAILURES=true
fi

if [ "$TESTS_PASSED" != "true" ]; then
    echo -e "${RED}‚ùå Tests failed${NC}"
    CRITICAL_FAILURES=true
fi

if [ "$CRITICAL_FAILURES" = "true" ]; then
    echo -e "\n${RED}üö´ PUSH BLOCKED${NC}"
    echo -e "${RED}Critical checks failed. Please fix the issues above before pushing.${NC}"
    echo -e "\n${YELLOW}üí° Tip: Use 'git commit --no-verify' only in emergencies${NC}"
    exit 1
else
    echo -e "\n${GREEN}‚úÖ ALL CRITICAL CHECKS PASSED${NC}"
    echo -e "${GREEN}üöÄ Ready to push!${NC}"

    # Show warnings if any
    echo -e "\n${YELLOW}‚ÑπÔ∏è  Note: Some non-critical checks may have warnings.${NC}"
    echo -e "${YELLOW}    Review the output above for details.${NC}"

    # Show analysis reports location
    if [ -f "cppcheck-report.xml" ]; then
        echo -e "${BLUE}üìä cppcheck report: cppcheck-report.xml${NC}"
    fi
    if [ -f "coverage.info" ]; then
        echo -e "${BLUE}üìä Coverage report: coverage.info (use 'genhtml coverage.info --output-directory coverage_html')${NC}"
    fi

    exit 0
fi